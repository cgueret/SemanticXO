'''
Created on Apr 11, 2011

@author: cgueret
'''
import logging
import httplib
import time
from rdflib import ConjunctiveGraph, RDF, URIRef, Namespace, Literal
from semanticxo.sparql import SPARQL

OLPC = Namespace("http://example.org/")
OLPC_TERMS = Namespace("http://example.org/terms#")

_QUERY_INT_KEY = ['timestamp', 'filesize', 'creation_time']

class MetadataStore(object):
    '''
        Store metadata into the triple store using HTTP calls.
    '''
    def __init__(self):
        self._url = '127.0.0.1:8080'
        
    def store(self, uid, metadata):
        logging.debug('[MDS] store ' + uid + ' ' + str(metadata))
        metadata['uid'] = uid
        
        # Preprocess the metadata
        props = {}
        for key, value in metadata.items():

            # Hack to support activities that still pass properties named as
            # for example title:text.
            if ':' in key:
                key = key.split(':', 1)[0]

            # Re-encode strings
            if isinstance(value, unicode):
                value = value.encode('utf-8')
            elif not isinstance(value, basestring):
                value = str(value)
            
            # Save new binding
            props[key] = value

        # Compose and save the graph
        graph = ConjunctiveGraph()
        resource = self._get_resource(uid)
        graph.add((resource, RDF.type, OLPC_TERMS['DSObject']))
        for key, value in props.items():
            if isinstance(key, basestring) and isinstance(value, basestring):
                key = OLPC_TERMS[key]
                try:
                    value = Literal(value)
                    graph.add((resource, key, value))
                except:
                    pass
                
        # Save it
        logging.debug('[MDS] save > %s' % graph.serialize())
        headers = { 'Accept' : '*/*', 'Content-Type': 'application/rdf+xml' }
        conn = httplib.HTTPConnection(self._url)
        conn.request("PUT", "/data/%s" % resource, body=graph.serialize(), headers=headers)
        conn.getresponse()
        conn.close()

        
    def retrieve(self, uid, properties=None):
        logging.debug('[MDS] retrieve %r' % uid)
        props = {}
        query = 'SELECT ?p ?o WHERE { <%s> ?p ?o. }' % self._get_resource(uid)
        sparql = SPARQL()
        for result in sparql.execute_select(query):
            logging.debug('[MDS] result %r' % result)
            print result
            if result['p'].startswith(OLPC_TERMS):
                key=result['p'].split(OLPC_TERMS)[1]
                if key in _QUERY_INT_KEY:
                    props[key] = int(result['o'])
                else:
                    props[key] = result['o']
                    
        # HACK: This is expected to be always present
        if 'creation_time' not in props:
            props['creation_time'] = int(time.time())
        
        return props
    
    def delete(self, uid):
        print '[MDS] delete'
        pass

    def get_property(self, uid, key):
        print '[MDS] get'
        pass

    def set_property(self, uid, key, value):
        print '[MDS] set'
        pass

    def _get_resource(self, uid):
        return URIRef(OLPC['resource/%s' % uid])
